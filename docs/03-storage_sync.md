# 03-storage_sync.md

## 3.1. 设计原则：将操作历史映射为消息流

在构建了一个强大的、为协作而生的数据模型之后，下一个关键挑战是设计一个高效、可靠且灵活的机制来持久化数据和同步更新。传统协作系统通常紧密耦合于特定的网络协议（如WebSocket）和后端架构（如中心化服务器），这限制了其部署的灵活性。

`.elf`的存储与同步架构基于一个核心的抽象原则：**将文档的CRDT操作历史记录（op log）映射为一个逻辑上的、持久化的消息发送流**。根据第二章的数据模型，文档的每一次变更都会生成一个或多个离散的、不可变的操作（operation）。我们可以将每一个这样的操作都看作是一条消息。因此，一个文档的完整历史就等同于一个按因果顺序排列的、包含了所有操作的消息队列或流。

这个简单的概念映射带来了巨大的架构优势。它将**数据模型（CRDT操作）**与**通信和存储（消息传递系统）**彻底解耦。一旦我们将问题重新定义为“如何可靠地传输、存储和查询一个命名的消息流”，我们就可以利用整个行业在消息队列、发布/订阅系统和分布式日志领域积累的成熟技术和解决方案，而无需重新发明轮子。这使得`.elf`的内核可以专注于CRDT逻辑，而将复杂的网络传输、路由、持久化和查询任务委托给一个专门的通信引擎。

## 3.2. 技术选型：Zenoh作为统一的数据中心网络

基于上述设计原则，我们选择了**Eclipse Zenoh**作为`.elf`底层的通信、存储和查询网络 。Zenoh并非一个简单的消息队列，而是一个集发布/订阅、分布式查询和存储于一体的统一数据中心协议，旨在统一处理动态数据（data in motion）、静态数据（data at rest）和计算 [1, 9]。Zenoh的架构特性与`.elf`的本地优先、去中心化协作的目标高度契合。

选择Zenoh的关键理由包括：

-   **拓扑无关性与去中心化**：Zenoh原生支持多种通信拓扑，包括点对点（P2P）、网状网络（Mesh）、路由模式（Routed）和代理模式（Brokered）。这意味着`.elf`文档可以在没有中心服务器的情况下，在局域网内的设备间直接同步；也可以通过Zenoh路由器跨越广域网和NAT，实现全球范围的协作。应用代码无需关心底层的网络拓扑。
-   **位置透明性**：在Zenoh网络中，数据生产者和消费者是解耦的。应用程序只需关心数据的“名字”（即Key Expression），而无需知道数据存储在哪里或由谁发布。Zenoh网络负责智能地路由数据和查询 。
-   **统一的API**：Zenoh通过一套统一的API来处理实时数据流（发布/订阅）和历史数据查询（查询/存储）。这完美地匹配了我们的核心抽象，即一个新加入的协作者既需要获取历史操作记录（数据在静止），也需要接收后续的实时更新（数据在运动）。
-   **高性能**：公开的性能评测显示，Zenoh在吞吐量和延迟方面显著优于MQTT、Kafka和DDS等主流协议，这对于提供流畅的实时协作体验至关重要 [10, 11, 12]。

## 3.3. 实现模型：Zenoh网络上的文档生命周期

`.elf`的数据模型与Zenoh的通信模型之间存在一种天然的、优雅的映射关系，这使得集成变得非常简单和高效。

-   **文档即键空间（Key-Space）**：每一个独立的`.elf`文档在Zenoh网络中被赋予一个唯一的键空间前缀，例如`/elf/docs/<doc_uuid>`。这个前缀成为了该文档在整个分布式系统中的唯一标识。
-   **操作即发布的消息**：当用户进行编辑时，由CRDT层生成的每一个原子操作（如第二章所述），都会被序列化并通过Zenoh**发布（PUT）**到该文档键空间下的一个特定子主题（或称通道）上，例如`/elf/docs/<doc_uuid>/ops`。
-   **事件流的实现**：因此，Zenoh通道上按时间顺序排列的消息流，就构成了该文档的完整、不可变的操作日志。
-   **实时同步**：已加入协作会话的客户端通过**订阅（SUBSCRIBE）**该主题来接收实时的更新操作。
-   **历史同步**：新加入的客户端或离线后重新上线的客户端，可以通过向该主题发起**查询（GET）**来获取所有历史操作记录。

这种设计将事件溯源的数据模型无缝地转化为一个发布/订阅/查询的通信模型。Zenoh的统一抽象使得实时同步（动态数据）和历史数据获取（静态数据）可以使用同一套API和底层机制来完成。一个新客户端只需对文档的键空间同时表达`GET`和`SUBSCRIBE`两种意图，Zenoh网络就会透明地处理从持久化存储中拉取历史数据，并转发后续的实时数据流，极大地简化了客户端的逻辑。

## 3.4. 通过Zenoh存储后端实现可插拔的持久化

`.elf`架构的一个核心优势在于将应用逻辑与底层的基础设施（存储和网络）彻底解耦，而Zenoh是实现这一目标的关键。Zenoh提供了一个强大的**存储后端（Storage Backend）插件机制** 。存储后端是一个特殊的Zenoh节点，它订阅特定的键空间，并将接收到的所有消息持久化到某种存储介质中。当有针对该键空间的查询请求时，存储后端会从介质中检索数据并返回。

这种机制为`.elf`带来了极大的灵活性：

-   **灵活的持久化选项**：通过为Zenoh路由器配置不同的存储后端插件，`.elf`文档的操作日志可以被持久化到任何地方，而无需修改`.elf`内核的任何代码。支持的存储选项包括：
    -   **文件系统后端**：将操作日志以文件形式存储在本地磁盘，适用于单机或简单的本地网络环境 。
    -   **RocksDB后端**：使用高性能的嵌入式键值数据库进行存储，适用于需要更高性能的服务器或桌面应用 。
    -   **InfluxDB后端**：适用于需要对操作历史进行复杂时序分析的场景 。
    -   **自定义后端**：可以通过Zenoh的API开发与其他任何数据库（如PostgreSQL, S3）集成的后端。
-   **真正的网络无关性**：`.elf`内核的职责仅限于向Zenoh网络发布和订阅CRDT操作。至于这些操作如何在网络中传输（TCP, UDP, QUIC）、如何路由、如何跨越NAT、以及最终如何被存储，完全由底层的Zenoh基础设施（由对等节点、路由器和存储节点组成）来决定和管理 。

这种架构使得`.elf`应用可以根据部署环境的需要，灵活地从一个完全离线的单机应用，无缝扩展为一个全球分布式的实时协作平台，而应用层的代码保持不变。

